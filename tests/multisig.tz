parameter (pair
             (pair
                (nat) # counter, used to prevent replay attacks
                (or    # payload to sign, represents the requested action
                   (pair    # transfer tokens
                      (mutez) # amount to transfer
                      (contract unit)) # destination to transfer to
                   (or
                      (option key_hash) # change the delegate to this address
                      (pair          # change the keys controlling the multisig
                         (nat)         # new threshold
                         (list key)))))     # new list of keys
             (list (option signature)));    # signatures

storage (pair
          (nat)
          (pair
            (nat)
            (list key))) ;

code
  {
    DUP ; CAR ; DIP { CDR } ; SWAP ; DUP ; DIP { SWAP } ;
    DIP
      {
        DUP ; CAR ; DIP { CDR } ;
        # pair the payload with the current contract address, to ensure signatures
        # can't be replayed accross different contracts if a key is reused.
        DUP ; SELF ; ADDRESS ; CHAIN_ID ; PAIR ; PAIR ;
        PACK ; # form the binary payload that we expect to be signed
        DIP { DUP ; CAR ; DIP { CDR } ; DIP { SWAP } } ; SWAP
      } ;

    # Check that the counters match
    DUP ; CAR ; DIP { CDR }; DIP { SWAP };
    COMPARE ; EQ ; IF {} {UNIT ; FAILWITH} ;

    # Compute the number of valid signatures
    DIP { SWAP } ; DUP ; CAR ; DIP { CDR };
    DIP
      {
        # Running count of valid signatures
        PUSH nat 0; SWAP ;
        ITER
          {
            DIP { SWAP } ; SWAP ;
            IF_CONS
              {
                IF_SOME
                  { SWAP ;
                    DIP
                      {
                        SWAP ; DIP 2 { DIP { DUP } ; SWAP } ;
                        # Checks signatures, fails if invalid
                        CHECK_SIGNATURE ; IF {} {UNIT ; FAILWITH} ;
                        PUSH nat 1 ; ADD } }
                  { SWAP ; DROP }
              }
              {
                # There were fewer signatures in the list
                # than keys. Not all signatures must be present, but
                # they should be marked as absent using the option type.
                UNIT; FAILWITH
              } ;
            SWAP
          }
      } ;
    # Assert that the threshold is less than or equal to the
    # number of valid signatures.
    COMPARE ; LE ; IF {} {UNIT ; FAILWITH} ;
    DROP ; DROP ;

    # Increment counter and place in storage
    DIP { DUP ; CAR ; DIP { CDR } ; PUSH nat 1 ; ADD ; PAIR} ;

    # We have now handled the signature verification part,
    # produce the operation requested by the signers.
    NIL operation ; SWAP ;
    IF_LEFT
      { # Transfer tokens
        DUP ; CAR ; DIP { CDR } ; UNIT ; TRANSFER_TOKENS ; CONS }
      { IF_LEFT {
                  # Change delegate
                  SET_DELEGATE ; CONS }
                {
                  # Change set of signatures
                  DIP { SWAP ; CAR } ; SWAP ; PAIR ; SWAP }} ;
    PAIR }
